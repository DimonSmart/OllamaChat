@page "/mcp-playground"
@using ChatClient.Domain.Models
@using ChatClient.Application.Services
@using System.Text.Json
@using System.Linq
@using ModelContextProtocol.Client
@using ChatClient.Api.Services
@inject IMcpClientService McpClientService
@inject IMcpServerConfigService McpServerConfigService
@inject ISnackbar Snackbar
@inject NavigationManager NavigationManager
@inject IDialogService DialogService
@inject ILogger<McpPlayground> Logger
@inject IMcpUserInteractionService McpUserInteractionService
@implements IDisposable

<PageTitle>MCP Playground</PageTitle>
<MudText Class="page-header">MCP Playground</MudText>

<MudStack Spacing="2">
    <MudSelect Label="Server" T="string" Value="@selectedServer" ValueChanged="OnServerChanged" Dense="true">
        @foreach (var s in servers)
        {
            <MudSelectItem Value="@s">
                <MudStack Spacing="0">
                    <MudText Typo="Typo.body2">@s</MudText>
                    @if (!string.IsNullOrWhiteSpace(GetServerDescription(s)))
                    {
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">@GetServerDescription(s)</MudText>
                    }
                </MudStack>
            </MudSelectItem>
        }
    </MudSelect>

    @if (!string.IsNullOrWhiteSpace(selectedServerDescription))
    {
        <MudAlert Severity="Severity.Info" Dense="true" Variant="Variant.Outlined">
            @selectedServerDescription
        </MudAlert>
    }

    <MudSelect Label="Function" T="string" Value="@selectedFunction" ValueChanged="OnFunctionChanged" Disabled="@(!tools.Any())" Dense="true">
        @foreach (var t in tools)
        {
            <MudSelectItem Value="@t.Name">
                <MudStack Spacing="0">
                    <MudText Typo="Typo.body2">@t.Name</MudText>
                    @if (!string.IsNullOrWhiteSpace(GetToolDescription(t)))
                    {
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">@GetToolDescription(t)</MudText>
                    }
                </MudStack>
            </MudSelectItem>
        }
    </MudSelect>

    @if (!string.IsNullOrWhiteSpace(selectedFunctionDescription))
    {
        <MudAlert Severity="Severity.Info" Dense="true" Variant="Variant.Outlined">
            @selectedFunctionDescription
        </MudAlert>
    }

    @if (fields.Any())
    {
        @foreach (var f in fields)
        {
            <MudStack Spacing="0">
                @switch (f.Type)
                {
                    case "boolean":
                        <MudSwitch T="bool" Checked="@(parameters.TryGetValue(f.Name, out var val) && val is bool b && b)"
                                   CheckedChanged="v => parameters[f.Name] = v"
                                   Label="@GetFieldLabel(f)" />
                        break;
                    case "integer":
                        <MudNumericField T="int?" Value="@(parameters[f.Name] as int?)"
                                         ValueChanged="v => parameters[f.Name] = v"
                                         Label="@GetFieldLabel(f)" />
                        break;
                    case "number":
                        <MudNumericField T="double?" Value="@(parameters[f.Name] as double?)"
                                         ValueChanged="v => parameters[f.Name] = v"
                                         Label="@GetFieldLabel(f)" />
                        break;
                    default:
                        <MudTextField T="string" Value="@(parameters.TryGetValue(f.Name, out var obj) ? obj?.ToString() : string.Empty)"
                                      ValueChanged="v => parameters[f.Name] = v"
                                      Label="@GetFieldLabel(f)" />
                        break;
                }
                <MudText Typo="Typo.caption" Class="mud-text-secondary mb-2">@GetFieldMetadata(f)</MudText>
            </MudStack>
        }
    }

    <MudButton Variant="Variant.Filled" OnClick="Call" Disabled="@(string.IsNullOrEmpty(selectedServer) || string.IsNullOrEmpty(selectedFunction))">Go</MudButton>

    <MudSwitch @bind-Value="showRaw" 
               Label="@(showRaw ? "Raw" : "Simplified")" 
               Disabled="@string.IsNullOrEmpty(rawResult)"
               Color="@(showRaw ? Color.Warning : Color.Success)" />

    @if (!string.IsNullOrEmpty(rawResult) || !string.IsNullOrEmpty(contentResult))
    {
        <MudPaper Class="pa-4 mcp-result" Outlined="true">
            <pre>@(showRaw ? rawResult : contentResult)</pre>
        </MudPaper>
    }
</MudStack>

@code {
    private readonly List<string> servers = [];
    private readonly Dictionary<string, string> serverAliases = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, string> serverDescriptions = new(StringComparer.OrdinalIgnoreCase);
    private readonly List<McpToolInfo> tools = [];
    private readonly Dictionary<string, McpClientTool> toolMap = new(StringComparer.OrdinalIgnoreCase);
    private readonly List<FieldInfo> fields = [];
    private readonly Dictionary<string, object?> parameters = new(StringComparer.OrdinalIgnoreCase);
    private McpClient? currentClient;
    private string? selectedServer;
    private string? selectedServerDescription;
    private string? selectedFunction;
    private string? selectedFunctionDescription;
    private string? rawResult;
    private string? contentResult;
    private bool showRaw = true;
    private IDisposable? elicitationHandlerRegistration;

    [Parameter, SupplyParameterFromQuery(Name = "server")]
    public string? McpServerName { get; set; }

    protected override async Task OnInitializedAsync()
    {
        elicitationHandlerRegistration = McpUserInteractionService.RegisterElicitationHandler(
            McpInteractionScope.Playground,
            HandleElicitationAsync);

        try
        {
            var clients = await McpClientService.GetMcpClientsAsync();
            servers.AddRange(clients
                .Select(c => c.ServerInfo.Name)
                .Where(name => !string.IsNullOrWhiteSpace(name))
                .Distinct(StringComparer.OrdinalIgnoreCase));

            var descriptors = await McpServerConfigService.GetAllAsync();
            foreach (var descriptor in descriptors.Where(d => !string.IsNullOrWhiteSpace(d.Name)))
            {
                serverDescriptions[descriptor.Name] = descriptor.Description;
            }

            BuildServerAliases();
            await ApplyPreselectedServer();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading servers: {ex.Message}", Severity.Error);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        await ApplyPreselectedServer();
    }

    private async Task ApplyPreselectedServer()
    {
        if (!servers.Any())
            return;

        if (string.IsNullOrWhiteSpace(McpServerName))
            return;

        var match = ResolveServerName(McpServerName);
        if (string.IsNullOrEmpty(match))
            return;

        if (string.Equals(selectedServer, match, StringComparison.OrdinalIgnoreCase))
            return;

        await OnServerChangedInternal(match, updateQuery: false);
    }

    private void BuildServerAliases()
    {
        serverAliases.Clear();
        foreach (var server in servers)
        {
            foreach (var alias in ExpandServerAliases(server))
            {
                AddServerAlias(alias, server);
            }
        }
    }

    private string? ResolveServerName(string queryServerName)
    {
        foreach (var alias in ExpandServerAliases(queryServerName))
        {
            if (serverAliases.TryGetValue(alias, out var aliasMatch))
                return aliasMatch;
        }

        return servers.FirstOrDefault(s => string.Equals(s, queryServerName, StringComparison.OrdinalIgnoreCase));
    }

    private static IEnumerable<string> ExpandServerAliases(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
            yield break;

        var trimmed = value.Trim();
        yield return trimmed;

        var pathTail = trimmed
            .Split(['/', '\\'], StringSplitOptions.RemoveEmptyEntries)
            .LastOrDefault();

        if (!string.IsNullOrWhiteSpace(pathTail) && !string.Equals(pathTail, trimmed, StringComparison.OrdinalIgnoreCase))
            yield return pathTail;

        var noExe = pathTail ?? trimmed;
        if (noExe.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
        {
            noExe = noExe[..^4];
            yield return noExe;
        }

        var dotTail = noExe
            .Split('.', StringSplitOptions.RemoveEmptyEntries)
            .LastOrDefault();
        if (!string.IsNullOrWhiteSpace(dotTail))
        {
            yield return dotTail;
        }
    }

    private void AddServerAlias(string? alias, string targetServer)
    {
        if (string.IsNullOrWhiteSpace(alias))
            return;

        serverAliases[alias] = targetServer;
    }

    private async Task OnServerChanged(string value)
        => await OnServerChangedInternal(value, updateQuery: true);

    private async Task OnServerChangedInternal(string value, bool updateQuery)
    {
        selectedServer = value;
        selectedServerDescription = GetServerDescription(selectedServer);
        if (updateQuery)
        {
            var url = NavigationManager.GetUriWithQueryParameter("server", string.IsNullOrWhiteSpace(selectedServer) ? null : selectedServer);
            NavigationManager.NavigateTo(url, replace: true);
        }

        selectedFunction = null;
        selectedFunctionDescription = null;
        tools.Clear();
        toolMap.Clear();
        fields.Clear();
        parameters.Clear();
        rawResult = null;
        contentResult = null;
        if (string.IsNullOrEmpty(selectedServer))
            return;
        try
        {
            var clients = await McpClientService.GetMcpClientsAsync();
            currentClient = clients.FirstOrDefault(c => string.Equals(c.ServerInfo.Name, selectedServer, StringComparison.OrdinalIgnoreCase));
            if (currentClient == null)
                return;
            var list = await McpClientService.GetMcpTools(currentClient);
            foreach (var t in list)
            {
                tools.Add(new McpToolInfo(t.Name, t.Description, t.JsonSchema));
                toolMap[t.Name] = t;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading tools: {ex.Message}", Severity.Error);
        }
    }

    private void OnFunctionChanged(string value)
    {
        selectedFunction = value;
        selectedFunctionDescription = GetToolDescription(tools.FirstOrDefault(t => string.Equals(t.Name, selectedFunction, StringComparison.OrdinalIgnoreCase)));
        fields.Clear();
        parameters.Clear();
        rawResult = null;
        contentResult = null;
        var tool = tools.FirstOrDefault(t => string.Equals(t.Name, selectedFunction, StringComparison.OrdinalIgnoreCase));
        if (tool == null)
            return;
        if (tool.JsonSchema.ValueKind == JsonValueKind.Undefined)
            return;

        var requiredParams = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (tool.JsonSchema.TryGetProperty("required", out var requiredNode) && requiredNode.ValueKind == JsonValueKind.Array)
        {
            foreach (var required in requiredNode.EnumerateArray())
            {
                if (required.ValueKind == JsonValueKind.String && !string.IsNullOrWhiteSpace(required.GetString()))
                    requiredParams.Add(required.GetString()!);
            }
        }

        if (tool.JsonSchema.TryGetProperty("properties", out var props) && props.ValueKind == JsonValueKind.Object)
        {
            foreach (var prop in props.EnumerateObject())
            {
                var type = prop.Value.TryGetProperty("type", out var t) ? t.GetString() : "string";
                var description = prop.Value.TryGetProperty("description", out var d) && d.ValueKind == JsonValueKind.String
                    ? d.GetString()
                    : null;
                fields.Add(new FieldInfo(prop.Name, type ?? "string", description, requiredParams.Contains(prop.Name)));
                parameters[prop.Name] = null;
            }
        }
    }

    private async Task Call()
    {
        if (currentClient == null || string.IsNullOrEmpty(selectedFunction))
            return;
        if (!toolMap.TryGetValue(selectedFunction, out var tool))
            return;
        try
        {
            var args = new Dictionary<string, object?>();
            foreach (var f in fields)
            {
                if (!parameters.TryGetValue(f.Name, out var val))
                    continue;
                if (val is string s && (f.Type == "array" || f.Type == "object"))
                {
                    try
                    {
                        val = JsonSerializer.Deserialize<JsonElement>(s);
                    }
                    catch
                    {
                        continue;
                    }
                }
                args[f.Name] = val;
            }
            using var interactionScope = McpUserInteractionService.BeginInteractionScope(McpInteractionScope.Playground);
            var obj = await tool.CallAsync(args, null, null);
            var elem = JsonSerializer.SerializeToElement(obj);
            rawResult = JsonSerializer.Serialize(elem, new JsonSerializerOptions { WriteIndented = true });
            contentResult = FormatContent(elem);
            showRaw = contentResult is null;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error calling function: {ex.Message}", Severity.Error);
        }
    }

    private async Task<McpElicitationResponse> HandleElicitationAsync(
        McpElicitationPrompt prompt,
        CancellationToken cancellationToken)
    {
        try
        {
            var response = McpElicitationResponse.Cancel;

            await InvokeAsync(async () =>
            {
                cancellationToken.ThrowIfCancellationRequested();

                var parameters = new DialogParameters
                {
                    ["Prompt"] = prompt
                };
                var options = new DialogOptions
                {
                    MaxWidth = MaxWidth.Small,
                    FullWidth = true,
                    BackdropClick = false,
                    CloseOnEscapeKey = true,
                    CloseButton = true
                };

                var dialog = await DialogService.ShowAsync<McpElicitationDialog>(
                    $"MCP input: {prompt.ServerName}",
                    parameters,
                    options);

                using var registration = cancellationToken.Register(() =>
                {
                    _ = InvokeAsync(() => dialog.Close(DialogResult.Ok(McpElicitationResponse.Cancel)));
                });

                var result = await dialog.Result;
                if (result?.Canceled != false)
                {
                    response = McpElicitationResponse.Cancel;
                    return;
                }

                response = result.Data as McpElicitationResponse ?? McpElicitationResponse.Cancel;
            });

            return response;
        }
        catch (OperationCanceledException)
        {
            return McpElicitationResponse.Cancel;
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to render elicitation dialog in MCP Playground.");
            Snackbar.Add($"Failed to handle MCP user prompt: {ex.Message}", Severity.Warning);
            return McpElicitationResponse.Cancel;
        }
    }

    private static string? FormatContent(JsonElement elem)
    {
        if (!elem.TryGetProperty("content", out var content))
            return null;
        return content.ValueKind switch
        {
            JsonValueKind.Array => string.Join("\n", content.EnumerateArray().Select(FormatContentItem)),
            JsonValueKind.String => FormatStringContent(content.GetString()),
            _ => JsonSerializer.Serialize(content, new JsonSerializerOptions { WriteIndented = true })
        };
    }

    private static string FormatContentItem(JsonElement elem)
    {
        if (elem.ValueKind == JsonValueKind.Object && elem.TryGetProperty("text", out var text) && text.ValueKind == JsonValueKind.String)
            return FormatStringContent(text.GetString());
        return JsonSerializer.Serialize(elem, new JsonSerializerOptions { WriteIndented = true });
    }

    private static string FormatStringContent(string? str)
    {
        if (string.IsNullOrEmpty(str))
            return string.Empty;
        try
        {
            using var doc = JsonDocument.Parse(str);
            return JsonSerializer.Serialize(doc.RootElement, new JsonSerializerOptions { WriteIndented = true });
        }
        catch
        {
            return str;
        }
    }

    private string? GetServerDescription(string? serverName)
    {
        if (string.IsNullOrWhiteSpace(serverName))
            return null;

        return serverDescriptions.TryGetValue(serverName, out var description) && !string.IsNullOrWhiteSpace(description)
            ? description
            : null;
    }

    private static string? GetToolDescription(McpToolInfo? tool)
    {
        if (tool == null)
            return null;

        if (!string.IsNullOrWhiteSpace(tool.Description))
            return tool.Description;

        if (tool.JsonSchema.ValueKind != JsonValueKind.Object)
            return null;

        if (tool.JsonSchema.TryGetProperty("description", out var descriptionNode) &&
            descriptionNode.ValueKind == JsonValueKind.String)
        {
            return descriptionNode.GetString();
        }

        return null;
    }

    private static string GetFieldLabel(FieldInfo field)
        => field.IsRequired ? $"{field.Name} *" : field.Name;

    private static string GetFieldMetadata(FieldInfo field)
    {
        var typePart = $"Type: {field.Type}";
        var requiredPart = field.IsRequired ? "Required." : "Optional.";

        if (string.IsNullOrWhiteSpace(field.Description))
            return $"{typePart}. {requiredPart}";

        return $"{field.Description} ({typePart}). {requiredPart}";
    }

    public void Dispose()
    {
        elicitationHandlerRegistration?.Dispose();
    }

    private sealed record FieldInfo(string Name, string Type, string? Description, bool IsRequired);
}
