@page "/vector-search"
@using ChatClient.Api.Services
@using ChatClient.Application.Services
@using ChatClient.Domain.Models
@using System.Linq
@using Microsoft.JSInterop
@inject ISnackbar Snackbar
@inject ILogger<VectorSearch> Logger
@implements IDisposable

<PageTitle>Vector Search</PageTitle>

<MudContainer MaxWidth="MaxWidth.Small" Class="pa-4">
    <MudStack Spacing="2">
        @if (!string.IsNullOrWhiteSpace(embeddingSetupMessage))
        {
            <MudAlert Severity="Severity.Warning" Dense="true" Variant="Variant.Outlined">
                <MudText Typo="Typo.body2">@embeddingSetupMessage</MudText>
                <MudButton Class="mt-2"
                           Variant="Variant.Outlined"
                           Color="Color.Warning"
                           Href="/app-settings"
                           StartIcon="@Icons.Material.Filled.Settings">
                    Open Application Settings
                </MudButton>
            </MudAlert>
        }

        <MudSelect T="AgentDescription"
                   Label="Select Agent"
                   Value="@selectedAgent"
                   ValueChanged="AgentChanged"
                   Variant="Variant.Outlined"
                   Dense="true"
                   FullWidth="true">
            @foreach (var agent in agents)
            {
                <MudSelectItem Value="@agent">@agent.AgentName</MudSelectItem>
            }
        </MudSelect>

        @if (isEmbeddingReady)
        {
            <ChatInput OnSend="SearchAsync" />
        }
        else
        {
            <MudText Typo="Typo.body2" Class="mt-1">
                Vector search is unavailable until the embedding model is configured and available.
            </MudText>
        }

        @if (results.Count > 0)
        {
            <MudText Typo="Typo.body2" Class="mt-2">Found @totalResults segments, showing @results.Count.</MudText>
            <MudStack Spacing="1" Class="mt-4">
                @foreach (var item in results)
                {
                    <MudPaper Class="pa-2" Style="user-select:text;">
                        <div style="display:flex;justify-content:space-between;">
                            <MudText Typo="Typo.subtitle2">@item.FileName</MudText>
                            <span class="copy-button" title="Copy" @onclick="() => CopyResult(item)">Copy</span>
                        </div>
                        <MudText Typo="Typo.body2">@item.Content</MudText>
                        <MudText Typo="Typo.caption">Score: @item.Score.ToString("0.###")</MudText>
                    </MudPaper>
                }
            </MudStack>
        }
        <MudText Typo="Typo.body2" Class="mt-2">
            Total files: @allFileCount (@allIndexedFiles indexed, @(allFileCount - allIndexedFiles) pending), size: @FormatSize(allTotalSize)
        </MudText>
        @if (selectedAgent is not null)
        {
            <MudText Typo="Typo.body2">@selectedAgent.AgentName: @fileCount files (@indexedFiles indexed), size: @FormatSize(totalSize)</MudText>
        }
        @if (indexStatus is not null)
        {
            var percent = indexStatus.Total == 0 ? 0 : indexStatus.Processed * 100 / indexStatus.Total;
            <MudText Typo="Typo.body2">Indexing @indexStatus.FileName: @percent%</MudText>
        }
    </MudStack>
</MudContainer>

@code {
    private List<AgentDescription> agents = [];
    private AgentDescription? selectedAgent;
    private List<RagSearchResult> results = [];
    private int totalResults;
    private int fileCount;
    private int indexedFiles;
    private long totalSize;
    private int allFileCount;
    private int allIndexedFiles;
    private long allTotalSize;
    private ServerModel embeddingModel = new(Guid.Empty, string.Empty);
    private bool isEmbeddingReady;
    private string? embeddingSetupMessage;
    private RagVectorIndexStatus? indexStatus;
    private System.Timers.Timer? statusTimer;

    [Inject] private IAgentDescriptionService AgentService { get; set; } = default!;
    [Inject] private IOllamaClientService OllamaService { get; set; } = default!;
    [Inject] private IRagVectorSearchService VectorSearchService { get; set; } = default!;
    [Inject] private IRagFileService RagFileService { get; set; } = default!;
    [Inject] private IUserSettingsService UserSettingsService { get; set; } = default!;
    [Inject] private IRagVectorIndexBackgroundService IndexBackgroundService { get; set; } = default!;
    [Inject] private IJSRuntime JSRuntime { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            agents = (await AgentService.GetAllAsync()).ToList();
            foreach (var agent in agents)
            {
                var files = await RagFileService.GetFilesAsync(agent.Id);
                allFileCount += files.Count;
                allIndexedFiles += files.Count(f => f.HasIndex);
                allTotalSize += files.Sum(f => f.Size);
            }

            await LoadEmbeddingModelStateAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize Vector Search page");
            isEmbeddingReady = false;
            embeddingSetupMessage ??= "Failed to initialize vector search. Check Application Settings.";
            Snackbar.Add("Failed to initialize Vector Search", Severity.Error);
        }

        statusTimer = new(1000);
        statusTimer.Elapsed += (_, _) =>
        {
            indexStatus = IndexBackgroundService.GetCurrentStatus();
            InvokeAsync(StateHasChanged);
        };
        statusTimer.Start();
    }

    private async Task AgentChanged(AgentDescription? agent)
    {
        selectedAgent = agent;
        results.Clear();
        totalResults = 0;
        fileCount = 0;
        totalSize = 0;
        if (selectedAgent is null) return;
        var files = await RagFileService.GetFilesAsync(selectedAgent.Id);
        fileCount = files.Count;
        totalSize = files.Sum(f => f.Size);
        indexedFiles = files.Count(f => f.HasIndex);
        indexStatus = IndexBackgroundService.GetCurrentStatus();
        StateHasChanged();
    }

    private async Task SearchAsync((string text, IReadOnlyList<AppChatMessageFile> _) data)
    {
        if (!isEmbeddingReady)
        {
            Snackbar.Add("Configure embedding model in Application Settings first.", Severity.Warning);
            return;
        }

        if (selectedAgent is null) return;
        var text = data.text.Trim();
        if (string.IsNullOrWhiteSpace(text)) return;

        try
        {
            var embedding = await OllamaService.GenerateEmbeddingAsync(text, embeddingModel);
            var response = await VectorSearchService.SearchAsync(selectedAgent.Id, new ReadOnlyMemory<float>(embedding));
            results = response.Results.ToList();
            totalResults = response.Total;
        }
        catch (Exception ex) when (!OllamaService.EmbeddingsAvailable)
        {
            Logger.LogWarning(ex, "Embedding service unavailable on Vector Search");
            isEmbeddingReady = false;
            embeddingSetupMessage = "Embedding service is unavailable. Configure a valid model in Application Settings.";
            Snackbar.Add("Embedding service unavailable. Open Application Settings.", Severity.Error);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Vector search failed");
            Snackbar.Add($"Vector search failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadEmbeddingModelStateAsync()
    {
        var settings = await UserSettingsService.GetSettingsAsync();
        if (!TryResolveEmbeddingModel(settings, out var model, out var setupError))
        {
            isEmbeddingReady = false;
            embeddingSetupMessage = setupError;
            return;
        }

        try
        {
            var models = await OllamaService.GetModelsAsync(model.ServerId);
            if (!models.Any(m => m.Name.Equals(model.ModelName, StringComparison.OrdinalIgnoreCase)))
            {
                isEmbeddingReady = false;
                embeddingSetupMessage = $"Embedding model '{model.ModelName}' is not available on the selected server.";
                return;
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Embedding model check failed for server {ServerId}", model.ServerId);
            isEmbeddingReady = false;
            embeddingSetupMessage = "Embedding model server is unavailable. Configure a valid model in Application Settings.";
            return;
        }

        embeddingModel = model;
        isEmbeddingReady = true;
        embeddingSetupMessage = null;
    }

    private static bool TryResolveEmbeddingModel(UserSettings settings, out ServerModel model, out string setupError)
    {
        if (IsModelConfigured(settings.Embedding.Model))
        {
            model = new ServerModel(settings.Embedding.Model.ServerId!.Value, settings.Embedding.Model.ModelName!);
            setupError = string.Empty;
            return true;
        }

        if (IsModelConfigured(settings.DefaultModel))
        {
            model = new ServerModel(settings.DefaultModel.ServerId!.Value, settings.DefaultModel.ModelName!);
            setupError = string.Empty;
            return true;
        }

        model = new ServerModel(Guid.Empty, string.Empty);
        setupError = "Embedding model is not configured. Set Embedding model (or Default model) in Application Settings.";
        return false;
    }

    private static bool IsModelConfigured(ServerModelSelection modelSelection) =>
        modelSelection.ServerId is { } id &&
        id != Guid.Empty &&
        !string.IsNullOrWhiteSpace(modelSelection.ModelName);

    private async Task CopyResult(RagSearchResult item)
    {
        var text = $"{item.FileName}\n{item.Content}\nScore: {item.Score:0.###}";
        await JSRuntime.InvokeVoidAsync("copyText", text);
    }

    private static string FormatSize(long bytes)
    {
        var sizes = new[] { "B", "KB", "MB", "GB" };
        double len = bytes;
        var order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.#} {sizes[order]}";
    }

    public void Dispose()
    {
        statusTimer?.Dispose();
    }
}
