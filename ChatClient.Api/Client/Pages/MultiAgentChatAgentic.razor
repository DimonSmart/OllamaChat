@page "/multi-agent-chat"
@page "/multi-agent-chat-agentic"
@using System.Collections.Generic
@using System.Collections.Immutable
@using System.Collections.ObjectModel
@using System.Globalization
@using System.Linq
@using System.Text
@using System.Text.Json
@using System.Text.RegularExpressions
@using System.Threading
@using ChatClient.Api.Client.Components
@using ChatClient.Api.Client.Services
@using ChatClient.Api.Client.Services.Agentic
@using ChatClient.Api.Client.Services.Formatters
@using ChatClient.Api.Client.ViewModels
@using ChatClient.Api.Services
@using ChatClient.Domain.Models
@using ChatClient.Application.Services
@using ChatClient.Application.Services.Agentic
@using ChatClient.Application.Helpers
@using ChatClient.Domain.Models.ChatStrategies
@using Microsoft.Extensions.AI
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using MudBlazor

@implements IAsyncDisposable
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject IDialogService DialogService
@inject IAgenticChatViewModelService ChatViewModelService
@inject IAgenticAppChatService ChatService
@inject IAgentDescriptionService AgentService
@inject IUserSettingsService UserSettingsService
@inject IEnumerable<IChatFormatter> ChatFormatters
@inject ILogger<MultiAgentChatAgentic> Logger
@inject ISavedChatService SavedChatService
@inject ISnackbar Snackbar
@inject ILlmServerConfigService LlmServerConfigService
@inject IOllamaClientService OllamaClientService

<PageTitle>Multi-Agentic Chat</PageTitle>

<OllamaCheck>
    <MudStack Class="chat-container">
    @if (isLoadingInitialData)
    {
        <MudOverlay Visible="true" DarkBackground="true" Absolute="true">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
            <MudText Class="mt-2">Loading chat...</MudText>
        </MudOverlay>
    }
    else if (!chatStarted)
    {
        <MudCard Class="ma-auto" Style="max-width: 600px; width: 100%;">
            <MudCardContent>
                @if (agents.Count == 0)
                {
                    <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true" />
                    <MudText>Loading agents...</MudText>
                }
                else
                {
                    <MudSelect T="AgentDescription" Label="Select Agents" SelectedValues="selectedAgents" SelectedValuesChanged="OnSelectedAgentsChanged" MultiSelection="true" Variant="Variant.Outlined" FullWidth="true" Dense="true">
                        @foreach (var agent in agents)
                        {
                            <MudSelectItem Value="@agent">@agent.AgentName</MudSelectItem>
                        }
                    </MudSelect>

                    <MudSelect T="string"
                               Label="Chat Strategy"
                               Value="chatStrategyName"
                               ValueChanged="OnChatStrategyChanged"
                               Variant="Variant.Outlined"
                               FullWidth="true"
                               Class="mt-4"
                               Dense="true">
                        @foreach (var strategy in chatStrategies)
                        {
                            <MudSelectItem Value="@strategy">@strategy</MudSelectItem>
                        }
                    </MudSelect>
                    @if (editorType is not null)
                    {
                        <DynamicComponent Type="editorType" Parameters="editorParams" />
                    }
                    else
                    {
                        <em>Editor for '@chatStrategyOptions.GetType().Name' not found</em>
                    }

                    <MudCheckBox @bind-Value="whiteboardEnabled"
                                 Label="Use whiteboard"
                                 Dense="true"
                                 Disabled="@(!isWhiteboardSupported)"
                                 Class="mt-2" />
                    @if (!isWhiteboardSupported && !string.IsNullOrWhiteSpace(whiteboardSupportHint))
                    {
                        <MudText Typo="Typo.caption" Color="Color.Warning" Class="ml-1">@whiteboardSupportHint</MudText>
                    }

                    <MudTooltip Text="Select server and model" Disabled="@CanStartChat">
                        <MudButton Variant="Variant.Filled"
                                   Color="Color.Primary"
                                   FullWidth="true"
                                   Class="mt-4"
                                   Size="Size.Medium"
                                   Disabled="@(!CanStartChat)"
                                   OnClick="StartChat">
                            Start Chat
                        </MudButton>
                    </MudTooltip>
                }
            </MudCardContent>
        </MudCard>
    }
    else
    {
        <div class="chat-actions">
            <MudMenu Icon="@Icons.Material.Filled.ContentCopy" AnchorOrigin="Origin.TopRight" TransformOrigin="Origin.TopRight">
                <MudMenuItem OnClick="@(() => CopyChatAsync(ChatFormat.Text))">Copy as Text</MudMenuItem>
                <MudMenuItem OnClick="@(() => CopyChatAsync(ChatFormat.Markdown))">Copy as Markdown</MudMenuItem>
                <MudMenuItem OnClick="@(() => CopyChatAsync(ChatFormat.Html))">Copy as HTML</MudMenuItem>
            </MudMenu>
            <MudIconButton Icon="@Icons.Material.Filled.Save" Color="Color.Primary" OnClick="SaveCurrentChat" />
        </div>
        <div class="chat-messages-container" @ref="messagesElement">
            @foreach (var message in ChatViewModelService.Messages)
            {
                if (message.Role == Microsoft.Extensions.AI.ChatRole.System)
                {
                    continue;
                }

                @if (message.Role == Microsoft.Extensions.AI.ChatRole.Tool)
                {
                    <RagDisplay Text="@message.Content" />
                }
                else
                {
                    <MudChat Dense="true" ChatPosition="@(message.Role == Microsoft.Extensions.AI.ChatRole.Assistant ? ChatBubblePosition.Start : ChatBubblePosition.End)" @key="message.Id">
                         <MudChatHeader>
                             <time>@message.MsgDateTime.ToString("g")</time>
                             <span class="copy-button" title="Copy answer" @onclick="(() => CopyVisibleMessage(message))">ðŸ“‹</span>
                             <span class="copy-button" title="Copy raw" @onclick="(() => CopyRawMessage(message))">ðŸšª</span>
                             @if (!isLLMAnswering)
                             {
                                 <span class="delete-button" title="Delete" @onclick="(() => DeleteMessage(message))">ðŸ—‘</span>
                             }
                         </MudChatHeader>

                        @{
                            var displayName = message.Role == Microsoft.Extensions.AI.ChatRole.Assistant
                                ? (message.AgentName ?? string.Empty)
                                : userSettings.UserName;
                            var avatarText = GetAvatarText(displayName);
                        }

                            @if (!string.IsNullOrEmpty(avatarText))
                        {
                            <MudAvatar Color="@(message.Role == Microsoft.Extensions.AI.ChatRole.Assistant ? Color.Primary : Color.Secondary)">
                                @avatarText
                            </MudAvatar>
                        }
                        
                        <MudChatBubble>
                            @if (message.Files.Any())
                            {
                                <div class="mb-2">
                                    @foreach (var file in message.Files)
                                    {
                                        @if (IsImageFile(file.ContentType))
                                        {
                                            <div class="image-thumbnail">
                                                <img src="@GetImageDataUrl(file)" 
                                                     alt="@file.Name" 
                                                     style="max-width: 150px; max-height: 150px; object-fit: cover;"
                                                     @onclick="@(() => ShowFullSizeImage(file))" />
                                                <MudText Typo="Typo.caption" Class="image-caption mt-1 text-center">
                                                    @file.Name (@FormatFileSize(file.Size))
                                                </MudText>
                                            </div>
                                        }
                                        else
                                        {
                                            <MudChip T="string" 
                                                     Color="Color.Info" 
                                                     Size="Size.Small"
                                                     Class="mb-1 mr-1">
                                                <MudIcon Icon="@GetFileIcon(file.ContentType)" Class="mr-1" />
                                                @file.Name (@FormatFileSize(file.Size))
                                            </MudChip>
                                        }
                                    }
                                </div>
                            }
                            @((MarkupString)message.HtmlContent)
                        </MudChatBubble>
                        @if (message.ThinkSegments.Any())
                        {
                            var validThoughts = message.ThinkSegments
                                .Select((segment, index) => new { segment, html = message.HtmlThinkSegments.ElementAt(index) })
                                .Where(x => !string.IsNullOrWhiteSpace(x.segment))
                                .ToList();

                            foreach (var thought in validThoughts)
                            {
                                <ThoughtDisplay PlainText="@thought.segment" HtmlText="@thought.html" />
                            }
                        }

                        @if (message.FunctionCalls.Any())
                        {
                            foreach (var call in message.FunctionCalls)
                            {
                                <McpCallDisplay Call="@call" />
                            }
                        }

                        @if (message.IsStreaming || message.IsCanceled || !string.IsNullOrEmpty(message.Statistics))
                        {
                            <MudChatFooter>
                                @if (message.IsStreaming)
                                {
                                    <MudText Typo="Typo.caption" Class="typing-indicator">typing...</MudText>
                                }
                                @if (message.IsCanceled)
                                {
                                    <MudAlert Severity="Severity.Error" Dense="true" Class="mt-1">
                                        Canceled
                                    </MudAlert>                                }
                                @if (!string.IsNullOrEmpty(message.Statistics))
                                {
                                    <div class="mt-1">
                                        <MudText Typo="Typo.caption" Class="mud-text-secondary">
                                            @((MarkupString)message.Statistics)
                                        </MudText>
                                    </div>
                                }
                            </MudChatFooter>
                        }
                    </MudChat>
                }
            }
          </div>
        
        <!-- Fixed input panel at bottom -->
        <div class="chat-input-panel">
            <MudStack>
                <ChatInput OnSend="SendChatMessageAsync"
                          ShowStopButton="isLLMAnswering"
                          OnStopClick="Cancel"
                          IsMultiAgent="true" />
            </MudStack>
        </div>
    }
</MudStack>
</OllamaCheck>

@code {
    private bool isLLMAnswering { get; set; } = false;
    private const int UpdateIntervalMs = 500;

    private bool isLoadingInitialData = true;
    private bool chatStarted = false;
    private Guid? lastSavedChatId;
    private string lastSavedChatTitle = string.Empty;
    private ElementReference messagesElement;

    private List<AgentDescription> agents = new();
    private List<AgentDescription> selectedAgents { get; set; } = new();
    private bool whiteboardEnabled = true;
    private bool isWhiteboardSupported = true;
    private string? whiteboardSupportHint;
    private ServerModelSelection lastUiModelSelection = new(null, null);

    [CascadingParameter(Name = "UiModelSelection")]
    public ServerModelSelection UiModelSelection { get; set; } = new(null, null);

    private string? currentModelName;

    private bool CanStartChat =>
        selectedAgents.Count > 0 &&
        selectedAgents.All(agent =>
            ModelSelectionHelper.TryGetEffectiveModel(
                new ServerModelSelection(agent.LlmId, agent.ModelName),
                UiModelSelection,
                out _));

    private const string RoundRobinChatStrategy = "RoundRobin";
    private const string RoundRobinSummaryChatStrategy = "RoundRobinWithSummary";
    private List<string> chatStrategies = new();
    private IChatStrategyOptions chatStrategyOptions = new RoundRobinChatStrategyOptions();
    private string chatStrategyName = RoundRobinChatStrategy;

    private static readonly IReadOnlyDictionary<Type, Type> Editors = new Dictionary<Type, Type>
    {
        { typeof(RoundRobinChatStrategyOptions), typeof(RoundRobinChatStrategyParameters) },
        { typeof(RoundRobinSummaryChatStrategyOptions), typeof(RoundRobinSummaryChatStrategyParameters) },
    }.ToImmutableDictionary();

    private Type? editorType => Editors.TryGetValue(chatStrategyOptions.GetType(), out var t) ? t : null;

    private Dictionary<string, object?> editorParams =>
        new() { ["Context"] = new ChatStrategyEditorContext(chatStrategyOptions, agents) };

    private UserSettings userSettings = new();

    private StreamingDebouncer _renderDebouncer = null!;

    private Func<AppChatMessageViewModel, Task>? _messageAddedHandler;
    private Func<AppChatMessageViewModel, MessageUpdateOptions, Task>? _messageUpdatedHandler;
    private Func<AppChatMessageViewModel, Task>? _messageDeletedHandler;

    protected override async Task OnInitializedAsync()
    {
        chatStrategies = new() { RoundRobinChatStrategy, RoundRobinSummaryChatStrategy };

        isLoadingInitialData = true;
        StateHasChanged();

        await LoadAgents();
        await LoadUserSettings();

        ChatService.AnsweringStateChanged += OnAnsweringStateChanged;
        ChatViewModelService.ChatReset += OnChatReset;
        _renderDebouncer = new StreamingDebouncer(UpdateIntervalMs, () => InvokeAsync(StateHasChanged));
        _messageAddedHandler = msg => InvokeAsync(() => OnMessageAdded(msg));
        _messageUpdatedHandler = (msg, opts) => InvokeAsync(() => OnMessageUpdated(msg, opts));
        _messageDeletedHandler = msg => InvokeAsync(() => OnMessageDeleted(msg));
        ChatViewModelService.MessageAdded += _messageAddedHandler;
       ChatViewModelService.MessageUpdated += _messageUpdatedHandler;
       ChatViewModelService.MessageDeleted += _messageDeletedHandler;

        isLoadingInitialData = false;
        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (SavedChatId.HasValue && SavedChatId != lastSavedChatId)
            await LoadSavedChat(SavedChatId.Value);

        if (!chatStarted && UiSelectionChanged())
        {
            lastUiModelSelection = new(UiModelSelection.ServerId, UiModelSelection.ModelName);
            await RefreshWhiteboardSupportAsync();
        }
    }

    private void OnAnsweringStateChanged(bool answering)
    {
        isLLMAnswering = answering;
        StateHasChanged();
    }

    private async Task OnMessageAdded(AppChatMessageViewModel message)
    {
        StateHasChanged();
        await ScrollToBottom();
    }    
    private Task OnMessageUpdated(AppChatMessageViewModel message, MessageUpdateOptions options)
    {
        return _renderDebouncer.TriggerAsync(options);
    }

    private void OnMessageDeleted(AppChatMessageViewModel message)
    {
        StateHasChanged();
    }

    private void OnChatReset()
    {
        chatStarted = false;
        lastSavedChatId = null;
        lastSavedChatTitle = string.Empty;
        whiteboardEnabled = true;
        isWhiteboardSupported = true;
        whiteboardSupportHint = null;
        StateHasChanged();
    }

    private void OnChatStrategyChanged(string name)
    {
        chatStrategyName = name;
        chatStrategyOptions = name switch
        {
            RoundRobinChatStrategy => new RoundRobinChatStrategyOptions(),
            RoundRobinSummaryChatStrategy => new RoundRobinSummaryChatStrategyOptions(),
            _ => new RoundRobinChatStrategyOptions()
        };
    }

    private async Task LoadAgents()
    {
        agents = (await AgentService.GetAllAsync()).ToList();
        selectedAgents = new List<AgentDescription>();
    }

    private async Task LoadUserSettings()
    {
        userSettings = await UserSettingsService.GetSettingsAsync();
        chatStrategyName = string.IsNullOrWhiteSpace(userSettings.ChatStrategyName)
            ? RoundRobinChatStrategy
            : userSettings.ChatStrategyName;

        chatStrategyOptions = chatStrategyName switch
        {
            RoundRobinChatStrategy => new RoundRobinChatStrategyOptions(),
            RoundRobinSummaryChatStrategy => new RoundRobinSummaryChatStrategyOptions(),
            _ => new RoundRobinChatStrategyOptions()
        };

        if (userSettings.MultiAgentSelectedAgents?.Count > 0)
        {
            selectedAgents = userSettings.MultiAgentSelectedAgents
                .Select(name => agents.FirstOrDefault(a => a.AgentName == name))
                .Where(a => a is not null)
                .Select(a => a!)
                .ToList();
        }
    }

    [Parameter, SupplyParameterFromQuery(Name = "saved")]
    public Guid? SavedChatId { get; set; }

    private async Task LoadSavedChat(Guid savedChatId)
    {
        var saved = await SavedChatService.GetByIdAsync(savedChatId);
        if (saved is null)
        {
            Snackbar.Add("Saved chat not found", Severity.Error);
            return;
        }

        var assistantIds = saved.Participants
            .Where(p => p.Role == ChatRole.Assistant)
            .Select(p => p.Id)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        selectedAgents = agents
            .Where(a => assistantIds.Contains(a.AgentId))
            .ToList();

        if (selectedAgents.Count == 0)
        {
            Snackbar.Add("Agents for saved chat not found", Severity.Error);
            return;
        }

        foreach (var agent in selectedAgents)
        {
            var configured = new ServerModelSelection(agent.LlmId, agent.ModelName);
            var effective = ModelSelectionHelper.GetEffectiveModel(configured, UiModelSelection, $"Agent: {agent.AgentName}", Logger);
            agent.ModelName = effective.ModelName;
            agent.LlmId = effective.ServerId;
        }

        currentModelName = selectedAgents[0].ModelName!;

        var modelsForSupport = selectedAgents
            .Where(a => a.LlmId.HasValue && !string.IsNullOrWhiteSpace(a.ModelName))
            .Select(a => (a, new ServerModel(a.LlmId!.Value, a.ModelName!)));
        await EvaluateWhiteboardSupportAsync(modelsForSupport);

        var allFunctions = selectedAgents.SelectMany(a => a.FunctionSettings.SelectedFunctions ?? []).ToList();
        var chatConfiguration = new AppChatConfiguration(currentModelName, allFunctions, whiteboardEnabled);

        var savedMessages = saved.Messages
            .Select(m =>
            {
                var msg = new AppChatMessage(m.Content, m.MsgDateTime, m.Role, agentName: m.AgentName);
                msg.Id = m.Id;
                return (IAppChatMessage)msg;
            }).ToList();

        var request = new ChatEngineSessionStartRequest
        {
            Configuration = chatConfiguration,
            Agents = selectedAgents.ToList(),
            History = savedMessages,
            ChatStrategyName = chatStrategyName,
            ChatStrategyOptions = chatStrategyOptions
        };
        await ChatService.StartAsync(request);
        chatStarted = true;
        lastSavedChatId = savedChatId;
        lastSavedChatTitle = saved.Title;
    }
    
    private async Task StartChat()
    {
        if (!CanStartChat)
            return;

        foreach (var agent in selectedAgents)
        {
            var configured = new ServerModelSelection(agent.LlmId, agent.ModelName);
            var effectiveModel = ModelSelectionHelper.GetEffectiveModel(
                configured,
                UiModelSelection,
                $"Agent: {agent.AgentName}",
                Logger);

            agent.ModelName = effectiveModel.ModelName;
            agent.LlmId = effectiveModel.ServerId;
        }

        currentModelName = selectedAgents[0].ModelName!;

        userSettings.ChatStrategyName = chatStrategyName;
        userSettings.MultiAgentSelectedAgents = selectedAgents.Select(a => a.AgentName).ToList();
        await UserSettingsService.SaveSettingsAsync(userSettings);

        var agentsForChat = selectedAgents.ToList();

        var allFunctions = agentsForChat.SelectMany(a => a.FunctionSettings.SelectedFunctions ?? []).ToList();
        var modelsForSupport = agentsForChat
            .Where(a => a.LlmId.HasValue && !string.IsNullOrWhiteSpace(a.ModelName))
            .Select(a => (a, new ServerModel(a.LlmId!.Value, a.ModelName!)));
        await EvaluateWhiteboardSupportAsync(modelsForSupport);

        var chatConfiguration = new AppChatConfiguration(currentModelName!, allFunctions, whiteboardEnabled);
        var request = new ChatEngineSessionStartRequest
        {
            Configuration = chatConfiguration,
            Agents = agentsForChat,
            ChatStrategyName = chatStrategyName,
            ChatStrategyOptions = chatStrategyOptions
        };
        await ChatService.StartAsync(request);
        chatStarted = true;
        StateHasChanged();
    }

    private async Task SaveCurrentChat()
    {
        if (!ChatService.Messages.Any())
        {
            Snackbar.Add("Nothing to save", Severity.Info);
            return;
        }

        var parameters = new DialogParameters
        {
            ["InitialTitle"] = SavedChatId.HasValue ? lastSavedChatTitle : string.Empty
        };
        var dialog = await DialogService.ShowAsync<SaveChatDialog>("Save Chat", parameters);
        var result = await dialog.Result;
        if (result?.Canceled != false)
            return;

        var title = result.Data as string ?? string.Empty;

        var participants = ChatService.AgentDescriptions
            .Select(a => new SavedChatParticipant(a.AgentId, a.AgentName, ChatRole.Assistant))
            .ToList();
        participants.Add(new SavedChatParticipant(userSettings.UserName.ToLowerInvariant(), userSettings.UserName, ChatRole.User));

        var agentMap = ChatService.AgentDescriptions.ToDictionary(a => a.AgentName, a => a.AgentId, StringComparer.OrdinalIgnoreCase);

        var messages = ChatService.Messages
            .Where(m => !m.IsStreaming && !m.IsCanceled && m.Role != ChatRole.System)
            .Where(m => !string.IsNullOrWhiteSpace(m.Content) || m.Files.Count > 0)
            .Select(m => new SavedChatMessage(
                m.Id,
                m.Content,
                m.MsgDateTime,
                m.Role,
                m.Role == ChatRole.Assistant && m.AgentName != null && agentMap.TryGetValue(m.AgentName, out var aid) ? aid : null,
                m.AgentName))
            .ToList();

        var chatId = SavedChatId ?? Guid.NewGuid();
        var chat = new SavedChat(chatId, title, DateTime.UtcNow, messages, participants);
        await SavedChatService.SaveAsync(chat);

        var isNew = !SavedChatId.HasValue;
        SavedChatId = chatId;
        lastSavedChatTitle = title;
        Snackbar.Add("Chat saved", Severity.Success);
        if (isNew)
            NavigationManager.NavigateTo(NavigationManager.GetUriWithQueryParameter("saved", chatId));
    }

    private async Task SendChatMessageAsync((string text, IReadOnlyList<AppChatMessageFile> files) messageData)
    {
        if (string.IsNullOrWhiteSpace(messageData.text) || isLLMAnswering)
            return;

        await ChatService.SendAsync(messageData.text.Trim(), messageData.files);
        await ScrollToBottom();
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", messagesElement);
        }        
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to scroll to bottom");
        }
    }

    private void Cancel()
    {        ChatService.CancelAsync();
    }

    private async Task DeleteMessage(AppChatMessageViewModel message)
    {
        if (isLLMAnswering)
            return;

        await ChatService.DeleteMessageAsync(message.Id);
    }

    private async Task CopyVisibleMessage(AppChatMessageViewModel message)
    {
        await JSRuntime.InvokeVoidAsync("copyText", message.Content);
    }

    private async Task CopyRawMessage(AppChatMessageViewModel message)
    {
        if (!string.IsNullOrEmpty(message.RawContent))
        {
            await JSRuntime.InvokeVoidAsync("copyText", message.RawContent);
        }
    }

    private async Task CopyChatAsync(ChatFormat format)
    {
        var formatter = ChatFormatters.FirstOrDefault(f => f.FormatType == format);
        if (formatter is null) return;
        var text = formatter.Format(ChatViewModelService.Messages);
        await JSRuntime.InvokeVoidAsync("copyText", text);
    }

    private async Task OnSelectedAgentsChanged(IEnumerable<AgentDescription> agents)
    {
        selectedAgents = agents.ToList();
        await RefreshWhiteboardSupportAsync();
    }

    private async Task RefreshWhiteboardSupportAsync()
    {
        if (selectedAgents.Count == 0)
        {
            isWhiteboardSupported = true;
            whiteboardSupportHint = null;
            StateHasChanged();
            return;
        }

        var models = selectedAgents
            .Select(agent =>
                ModelSelectionHelper.TryGetEffectiveModel(new ServerModelSelection(agent.LlmId, agent.ModelName), UiModelSelection, out var model)
                    ? (agent, model)
                    : (agent, (ServerModel?)null))
            .Where(pair => pair.Item2 is not null)
            .Select(pair => (pair.agent, pair.Item2!));

        await EvaluateWhiteboardSupportAsync(models);
    }

    private async Task EvaluateWhiteboardSupportAsync(IEnumerable<(AgentDescription agent, ServerModel model)> agentModels)
    {
        isWhiteboardSupported = true;
        whiteboardSupportHint = null;

        foreach (var (agent, model) in agentModels)
        {
            if (!await SupportsFunctionCallingAsync(model))
            {
                isWhiteboardSupported = false;
                whiteboardEnabled = false;
                whiteboardSupportHint = $"Whiteboard disabled because {agent.AgentName} uses {model.ModelName} without function support.";
                break;
            }
        }

        StateHasChanged();
    }

    private async Task<bool> SupportsFunctionCallingAsync(ServerModel model)
    {
        var server = await LlmServerConfigService.GetByIdAsync(model.ServerId);
        if (server?.ServerType != ServerType.Ollama)
        {
            return true;
        }

        try
        {
            var models = await OllamaClientService.GetModelsAsync(model.ServerId);
            var ollamaModel = models.FirstOrDefault(m => string.Equals(m.Name, model.ModelName, StringComparison.OrdinalIgnoreCase));
            return ollamaModel?.SupportsFunctionCalling != false;
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to determine function support for model {ModelName}", model.ModelName);
            return true;
        }
    }

    private bool UiSelectionChanged() =>
        UiModelSelection.ServerId != lastUiModelSelection.ServerId ||
        UiModelSelection.ModelName != lastUiModelSelection.ModelName;

    public async ValueTask DisposeAsync()
    {
        ChatService.AnsweringStateChanged -= OnAnsweringStateChanged;
        ChatViewModelService.ChatReset -= OnChatReset;
        if (_messageAddedHandler != null)
            ChatViewModelService.MessageAdded -= _messageAddedHandler;
        if (_messageUpdatedHandler != null)
            ChatViewModelService.MessageUpdated -= _messageUpdatedHandler;
        if (_messageDeletedHandler != null)
            ChatViewModelService.MessageDeleted -= _messageDeletedHandler;

        await ChatService.CancelAsync();
        ChatService.ResetChat();
    }

    private string GetFileIcon(string contentType)
    {
        return contentType.ToLower() switch
        {
            var ct when ct.StartsWith("image/") => Icons.Material.Filled.Image,
            var ct when ct.Contains("pdf") => Icons.Material.Filled.PictureAsPdf,
            var ct when ct.Contains("text") => Icons.Material.Filled.Description,
            var ct when ct.Contains("word") || ct.Contains("document") => Icons.Material.Filled.Description,
            _ => Icons.Material.Filled.AttachFile
        };
    }    

    private string FormatFileSize(long bytes)
    {
        string[] suffixes = ["B", "KB", "MB", "GB"];
        int counter = 0;
        decimal number = bytes;
        while (Math.Round(number / 1024) >= 1)
        {
            number /= 1024;
            counter++;
        }
        return $"{number:n1} {suffixes[counter]}";
    }

    private bool IsImageFile(string contentType)
    {
        return contentType.ToLower().StartsWith("image/");
    }

    private string GetImageDataUrl(AppChatMessageFile file)
    {
        return $"data:{file.ContentType};base64,{Convert.ToBase64String(file.Data)}";
    }    private async Task ShowFullSizeImage(AppChatMessageFile file)
    {
        var parameters = new DialogParameters
        {
            ["ImageFile"] = file
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true,
            BackdropClick = true
        };

        await DialogService.ShowAsync<ImageViewerDialog>("Image Viewer", parameters, options);
    }

    private string GetAvatarText(string? name) => string.IsNullOrWhiteSpace(name) ? string.Empty : name;
}
